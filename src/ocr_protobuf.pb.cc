// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ocr_protobuf.proto

#include "ocr_protobuf.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace ocr_protobuf {
PROTOBUF_CONSTEXPR OcrRespond_OcrBoxPoint::OcrRespond_OcrBoxPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0} {}
struct OcrRespond_OcrBoxPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OcrRespond_OcrBoxPointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OcrRespond_OcrBoxPointDefaultTypeInternal() {}
  union {
    OcrRespond_OcrBoxPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OcrRespond_OcrBoxPointDefaultTypeInternal _OcrRespond_OcrBoxPoint_default_instance_;
PROTOBUF_CONSTEXPR OcrRespond_OcrBox::OcrRespond_OcrBox(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.topleft_)*/nullptr
  , /*decltype(_impl_.topright_)*/nullptr
  , /*decltype(_impl_.bottomright_)*/nullptr
  , /*decltype(_impl_.bottomleft_)*/nullptr} {}
struct OcrRespond_OcrBoxDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OcrRespond_OcrBoxDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OcrRespond_OcrBoxDefaultTypeInternal() {}
  union {
    OcrRespond_OcrBox _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OcrRespond_OcrBoxDefaultTypeInternal _OcrRespond_OcrBox_default_instance_;
PROTOBUF_CONSTEXPR OcrRespond_OCRResultChar::OcrRespond_OCRResultChar(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.chars_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.char_box_)*/nullptr} {}
struct OcrRespond_OCRResultCharDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OcrRespond_OCRResultCharDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OcrRespond_OCRResultCharDefaultTypeInternal() {}
  union {
    OcrRespond_OCRResultChar _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OcrRespond_OCRResultCharDefaultTypeInternal _OcrRespond_OCRResultChar_default_instance_;
PROTOBUF_CONSTEXPR OcrRespond_OCRResultLine::OcrRespond_OCRResultLine(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.blocks_)*/{}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.line_box_)*/nullptr
  , /*decltype(_impl_.box10_)*/nullptr
  , /*decltype(_impl_.rate_)*/0
  , /*decltype(_impl_.left_)*/0
  , /*decltype(_impl_.top_)*/0
  , /*decltype(_impl_.right_)*/0
  , /*decltype(_impl_.bottom_)*/0
  , /*decltype(_impl_.unknown_0_)*/false} {}
struct OcrRespond_OCRResultLineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OcrRespond_OCRResultLineDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OcrRespond_OCRResultLineDefaultTypeInternal() {}
  union {
    OcrRespond_OCRResultLine _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OcrRespond_OCRResultLineDefaultTypeInternal _OcrRespond_OCRResultLine_default_instance_;
PROTOBUF_CONSTEXPR OcrRespond_OcrOutputBuffer::OcrRespond_OcrOutputBuffer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.lines_)*/{}
  , /*decltype(_impl_.unk4_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.img_width_)*/0u
  , /*decltype(_impl_.img_height_)*/0u} {}
struct OcrRespond_OcrOutputBufferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OcrRespond_OcrOutputBufferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OcrRespond_OcrOutputBufferDefaultTypeInternal() {}
  union {
    OcrRespond_OcrOutputBuffer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OcrRespond_OcrOutputBufferDefaultTypeInternal _OcrRespond_OcrOutputBuffer_default_instance_;
PROTOBUF_CONSTEXPR OcrRespond::OcrRespond(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ocr_result_)*/nullptr
  , /*decltype(_impl_.task_id_)*/uint64_t{0u}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.err_code_)*/0} {}
struct OcrRespondDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OcrRespondDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OcrRespondDefaultTypeInternal() {}
  union {
    OcrRespond _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OcrRespondDefaultTypeInternal _OcrRespond_default_instance_;
PROTOBUF_CONSTEXPR OcrRequest_OcrInputBuffer::OcrRequest_OcrInputBuffer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pic_path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pic_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.u2_)*/0u
  , /*decltype(_impl_.u3_)*/0u} {}
struct OcrRequest_OcrInputBufferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OcrRequest_OcrInputBufferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OcrRequest_OcrInputBufferDefaultTypeInternal() {}
  union {
    OcrRequest_OcrInputBuffer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OcrRequest_OcrInputBufferDefaultTypeInternal _OcrRequest_OcrInputBuffer_default_instance_;
PROTOBUF_CONSTEXPR OcrRequest::OcrRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.input_)*/nullptr
  , /*decltype(_impl_.task_id_)*/uint64_t{0u}
  , /*decltype(_impl_.unknow_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct OcrRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR OcrRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~OcrRequestDefaultTypeInternal() {}
  union {
    OcrRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 OcrRequestDefaultTypeInternal _OcrRequest_default_instance_;
}  // namespace ocr_protobuf
namespace ocr_protobuf {

// ===================================================================

class OcrRespond_OcrBoxPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<OcrRespond_OcrBoxPoint>()._impl_._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

OcrRespond_OcrBoxPoint::OcrRespond_OcrBoxPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ocr_protobuf.OcrRespond.OcrBoxPoint)
}
OcrRespond_OcrBoxPoint::OcrRespond_OcrBoxPoint(const OcrRespond_OcrBoxPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OcrRespond_OcrBoxPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:ocr_protobuf.OcrRespond.OcrBoxPoint)
}

inline void OcrRespond_OcrBoxPoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
  };
}

OcrRespond_OcrBoxPoint::~OcrRespond_OcrBoxPoint() {
  // @@protoc_insertion_point(destructor:ocr_protobuf.OcrRespond.OcrBoxPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OcrRespond_OcrBoxPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void OcrRespond_OcrBoxPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OcrRespond_OcrBoxPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:ocr_protobuf.OcrRespond.OcrBoxPoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.y_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OcrRespond_OcrBoxPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OcrRespond_OcrBoxPoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ocr_protobuf.OcrRespond.OcrBoxPoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional float x = 1;
  if (_internal_has_x()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // optional float y = 2;
  if (_internal_has_y()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ocr_protobuf.OcrRespond.OcrBoxPoint)
  return target;
}

size_t OcrRespond_OcrBoxPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ocr_protobuf.OcrRespond.OcrBoxPoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OcrRespond_OcrBoxPoint::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OcrRespond_OcrBoxPoint*>(
      &from));
}

void OcrRespond_OcrBoxPoint::MergeFrom(const OcrRespond_OcrBoxPoint& from) {
  OcrRespond_OcrBoxPoint* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:ocr_protobuf.OcrRespond.OcrBoxPoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OcrRespond_OcrBoxPoint::CopyFrom(const OcrRespond_OcrBoxPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ocr_protobuf.OcrRespond.OcrBoxPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OcrRespond_OcrBoxPoint::IsInitialized() const {
  return true;
}

void OcrRespond_OcrBoxPoint::InternalSwap(OcrRespond_OcrBoxPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OcrRespond_OcrBoxPoint, _impl_.y_)
      + sizeof(OcrRespond_OcrBoxPoint::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(OcrRespond_OcrBoxPoint, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

std::string OcrRespond_OcrBoxPoint::GetTypeName() const {
  return "ocr_protobuf.OcrRespond.OcrBoxPoint";
}


// ===================================================================

class OcrRespond_OcrBox::_Internal {
 public:
  using HasBits = decltype(std::declval<OcrRespond_OcrBox>()._impl_._has_bits_);
  static const ::ocr_protobuf::OcrRespond_OcrBoxPoint& topleft(const OcrRespond_OcrBox* msg);
  static void set_has_topleft(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ocr_protobuf::OcrRespond_OcrBoxPoint& topright(const OcrRespond_OcrBox* msg);
  static void set_has_topright(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ocr_protobuf::OcrRespond_OcrBoxPoint& bottomright(const OcrRespond_OcrBox* msg);
  static void set_has_bottomright(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::ocr_protobuf::OcrRespond_OcrBoxPoint& bottomleft(const OcrRespond_OcrBox* msg);
  static void set_has_bottomleft(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::ocr_protobuf::OcrRespond_OcrBoxPoint&
OcrRespond_OcrBox::_Internal::topleft(const OcrRespond_OcrBox* msg) {
  return *msg->_impl_.topleft_;
}
const ::ocr_protobuf::OcrRespond_OcrBoxPoint&
OcrRespond_OcrBox::_Internal::topright(const OcrRespond_OcrBox* msg) {
  return *msg->_impl_.topright_;
}
const ::ocr_protobuf::OcrRespond_OcrBoxPoint&
OcrRespond_OcrBox::_Internal::bottomright(const OcrRespond_OcrBox* msg) {
  return *msg->_impl_.bottomright_;
}
const ::ocr_protobuf::OcrRespond_OcrBoxPoint&
OcrRespond_OcrBox::_Internal::bottomleft(const OcrRespond_OcrBox* msg) {
  return *msg->_impl_.bottomleft_;
}
OcrRespond_OcrBox::OcrRespond_OcrBox(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ocr_protobuf.OcrRespond.OcrBox)
}
OcrRespond_OcrBox::OcrRespond_OcrBox(const OcrRespond_OcrBox& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OcrRespond_OcrBox* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.topleft_){nullptr}
    , decltype(_impl_.topright_){nullptr}
    , decltype(_impl_.bottomright_){nullptr}
    , decltype(_impl_.bottomleft_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_topleft()) {
    _this->_impl_.topleft_ = new ::ocr_protobuf::OcrRespond_OcrBoxPoint(*from._impl_.topleft_);
  }
  if (from._internal_has_topright()) {
    _this->_impl_.topright_ = new ::ocr_protobuf::OcrRespond_OcrBoxPoint(*from._impl_.topright_);
  }
  if (from._internal_has_bottomright()) {
    _this->_impl_.bottomright_ = new ::ocr_protobuf::OcrRespond_OcrBoxPoint(*from._impl_.bottomright_);
  }
  if (from._internal_has_bottomleft()) {
    _this->_impl_.bottomleft_ = new ::ocr_protobuf::OcrRespond_OcrBoxPoint(*from._impl_.bottomleft_);
  }
  // @@protoc_insertion_point(copy_constructor:ocr_protobuf.OcrRespond.OcrBox)
}

inline void OcrRespond_OcrBox::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.topleft_){nullptr}
    , decltype(_impl_.topright_){nullptr}
    , decltype(_impl_.bottomright_){nullptr}
    , decltype(_impl_.bottomleft_){nullptr}
  };
}

OcrRespond_OcrBox::~OcrRespond_OcrBox() {
  // @@protoc_insertion_point(destructor:ocr_protobuf.OcrRespond.OcrBox)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OcrRespond_OcrBox::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.topleft_;
  if (this != internal_default_instance()) delete _impl_.topright_;
  if (this != internal_default_instance()) delete _impl_.bottomright_;
  if (this != internal_default_instance()) delete _impl_.bottomleft_;
}

void OcrRespond_OcrBox::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OcrRespond_OcrBox::Clear() {
// @@protoc_insertion_point(message_clear_start:ocr_protobuf.OcrRespond.OcrBox)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.topleft_ != nullptr);
      _impl_.topleft_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.topright_ != nullptr);
      _impl_.topright_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.bottomright_ != nullptr);
      _impl_.bottomright_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.bottomleft_ != nullptr);
      _impl_.bottomleft_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OcrRespond_OcrBox::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ocr_protobuf.OcrRespond.OcrBoxPoint topleft = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_topleft(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ocr_protobuf.OcrRespond.OcrBoxPoint topright = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_topright(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ocr_protobuf.OcrRespond.OcrBoxPoint bottomright = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_bottomright(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ocr_protobuf.OcrRespond.OcrBoxPoint bottomleft = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_bottomleft(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OcrRespond_OcrBox::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ocr_protobuf.OcrRespond.OcrBox)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .ocr_protobuf.OcrRespond.OcrBoxPoint topleft = 1;
  if (_internal_has_topleft()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::topleft(this),
        _Internal::topleft(this).GetCachedSize(), target, stream);
  }

  // optional .ocr_protobuf.OcrRespond.OcrBoxPoint topright = 2;
  if (_internal_has_topright()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::topright(this),
        _Internal::topright(this).GetCachedSize(), target, stream);
  }

  // optional .ocr_protobuf.OcrRespond.OcrBoxPoint bottomright = 3;
  if (_internal_has_bottomright()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::bottomright(this),
        _Internal::bottomright(this).GetCachedSize(), target, stream);
  }

  // optional .ocr_protobuf.OcrRespond.OcrBoxPoint bottomleft = 4;
  if (_internal_has_bottomleft()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::bottomleft(this),
        _Internal::bottomleft(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ocr_protobuf.OcrRespond.OcrBox)
  return target;
}

size_t OcrRespond_OcrBox::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ocr_protobuf.OcrRespond.OcrBox)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .ocr_protobuf.OcrRespond.OcrBoxPoint topleft = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.topleft_);
    }

    // optional .ocr_protobuf.OcrRespond.OcrBoxPoint topright = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.topright_);
    }

    // optional .ocr_protobuf.OcrRespond.OcrBoxPoint bottomright = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.bottomright_);
    }

    // optional .ocr_protobuf.OcrRespond.OcrBoxPoint bottomleft = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.bottomleft_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OcrRespond_OcrBox::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OcrRespond_OcrBox*>(
      &from));
}

void OcrRespond_OcrBox::MergeFrom(const OcrRespond_OcrBox& from) {
  OcrRespond_OcrBox* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:ocr_protobuf.OcrRespond.OcrBox)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_topleft()->::ocr_protobuf::OcrRespond_OcrBoxPoint::MergeFrom(
          from._internal_topleft());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_topright()->::ocr_protobuf::OcrRespond_OcrBoxPoint::MergeFrom(
          from._internal_topright());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_bottomright()->::ocr_protobuf::OcrRespond_OcrBoxPoint::MergeFrom(
          from._internal_bottomright());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_bottomleft()->::ocr_protobuf::OcrRespond_OcrBoxPoint::MergeFrom(
          from._internal_bottomleft());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OcrRespond_OcrBox::CopyFrom(const OcrRespond_OcrBox& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ocr_protobuf.OcrRespond.OcrBox)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OcrRespond_OcrBox::IsInitialized() const {
  return true;
}

void OcrRespond_OcrBox::InternalSwap(OcrRespond_OcrBox* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OcrRespond_OcrBox, _impl_.bottomleft_)
      + sizeof(OcrRespond_OcrBox::_impl_.bottomleft_)
      - PROTOBUF_FIELD_OFFSET(OcrRespond_OcrBox, _impl_.topleft_)>(
          reinterpret_cast<char*>(&_impl_.topleft_),
          reinterpret_cast<char*>(&other->_impl_.topleft_));
}

std::string OcrRespond_OcrBox::GetTypeName() const {
  return "ocr_protobuf.OcrRespond.OcrBox";
}


// ===================================================================

class OcrRespond_OCRResultChar::_Internal {
 public:
  using HasBits = decltype(std::declval<OcrRespond_OCRResultChar>()._impl_._has_bits_);
  static const ::ocr_protobuf::OcrRespond_OcrBox& char_box(const OcrRespond_OCRResultChar* msg);
  static void set_has_char_box(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_chars(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ocr_protobuf::OcrRespond_OcrBox&
OcrRespond_OCRResultChar::_Internal::char_box(const OcrRespond_OCRResultChar* msg) {
  return *msg->_impl_.char_box_;
}
OcrRespond_OCRResultChar::OcrRespond_OCRResultChar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ocr_protobuf.OcrRespond.OCRResultChar)
}
OcrRespond_OCRResultChar::OcrRespond_OCRResultChar(const OcrRespond_OCRResultChar& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OcrRespond_OCRResultChar* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chars_){}
    , decltype(_impl_.char_box_){nullptr}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.chars_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chars_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chars()) {
    _this->_impl_.chars_.Set(from._internal_chars(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_char_box()) {
    _this->_impl_.char_box_ = new ::ocr_protobuf::OcrRespond_OcrBox(*from._impl_.char_box_);
  }
  // @@protoc_insertion_point(copy_constructor:ocr_protobuf.OcrRespond.OCRResultChar)
}

inline void OcrRespond_OCRResultChar::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.chars_){}
    , decltype(_impl_.char_box_){nullptr}
  };
  _impl_.chars_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.chars_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OcrRespond_OCRResultChar::~OcrRespond_OCRResultChar() {
  // @@protoc_insertion_point(destructor:ocr_protobuf.OcrRespond.OCRResultChar)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OcrRespond_OCRResultChar::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.chars_.Destroy();
  if (this != internal_default_instance()) delete _impl_.char_box_;
}

void OcrRespond_OCRResultChar::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OcrRespond_OCRResultChar::Clear() {
// @@protoc_insertion_point(message_clear_start:ocr_protobuf.OcrRespond.OCRResultChar)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.chars_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.char_box_ != nullptr);
      _impl_.char_box_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OcrRespond_OCRResultChar::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ocr_protobuf.OcrRespond.OcrBox char_box = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_char_box(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string chars = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_chars();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OcrRespond_OCRResultChar::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ocr_protobuf.OcrRespond.OCRResultChar)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional .ocr_protobuf.OcrRespond.OcrBox char_box = 1;
  if (_internal_has_char_box()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::char_box(this),
        _Internal::char_box(this).GetCachedSize(), target, stream);
  }

  // optional string chars = 2;
  if (_internal_has_chars()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_chars().data(), static_cast<int>(this->_internal_chars().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ocr_protobuf.OcrRespond.OCRResultChar.chars");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_chars(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ocr_protobuf.OcrRespond.OCRResultChar)
  return target;
}

size_t OcrRespond_OCRResultChar::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ocr_protobuf.OcrRespond.OCRResultChar)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string chars = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chars());
    }

    // optional .ocr_protobuf.OcrRespond.OcrBox char_box = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.char_box_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OcrRespond_OCRResultChar::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OcrRespond_OCRResultChar*>(
      &from));
}

void OcrRespond_OCRResultChar::MergeFrom(const OcrRespond_OCRResultChar& from) {
  OcrRespond_OCRResultChar* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:ocr_protobuf.OcrRespond.OCRResultChar)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_chars(from._internal_chars());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_char_box()->::ocr_protobuf::OcrRespond_OcrBox::MergeFrom(
          from._internal_char_box());
    }
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OcrRespond_OCRResultChar::CopyFrom(const OcrRespond_OCRResultChar& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ocr_protobuf.OcrRespond.OCRResultChar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OcrRespond_OCRResultChar::IsInitialized() const {
  return true;
}

void OcrRespond_OCRResultChar::InternalSwap(OcrRespond_OCRResultChar* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.chars_, lhs_arena,
      &other->_impl_.chars_, rhs_arena
  );
  swap(_impl_.char_box_, other->_impl_.char_box_);
}

std::string OcrRespond_OCRResultChar::GetTypeName() const {
  return "ocr_protobuf.OcrRespond.OCRResultChar";
}


// ===================================================================

class OcrRespond_OCRResultLine::_Internal {
 public:
  using HasBits = decltype(std::declval<OcrRespond_OCRResultLine>()._impl_._has_bits_);
  static const ::ocr_protobuf::OcrRespond_OcrBox& line_box(const OcrRespond_OCRResultLine* msg);
  static void set_has_unknown_0(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::ocr_protobuf::OcrRespond_OcrBox& box10(const OcrRespond_OCRResultLine* msg);
  static void set_has_box10(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ocr_protobuf::OcrRespond_OcrBox&
OcrRespond_OCRResultLine::_Internal::line_box(const OcrRespond_OCRResultLine* msg) {
  return *msg->_impl_.line_box_;
}
const ::ocr_protobuf::OcrRespond_OcrBox&
OcrRespond_OCRResultLine::_Internal::box10(const OcrRespond_OCRResultLine* msg) {
  return *msg->_impl_.box10_;
}
OcrRespond_OCRResultLine::OcrRespond_OCRResultLine(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ocr_protobuf.OcrRespond.OCRResultLine)
}
OcrRespond_OCRResultLine::OcrRespond_OCRResultLine(const OcrRespond_OCRResultLine& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OcrRespond_OCRResultLine* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.blocks_){from._impl_.blocks_}
    , decltype(_impl_.text_){}
    , decltype(_impl_.line_box_){nullptr}
    , decltype(_impl_.box10_){nullptr}
    , decltype(_impl_.rate_){}
    , decltype(_impl_.left_){}
    , decltype(_impl_.top_){}
    , decltype(_impl_.right_){}
    , decltype(_impl_.bottom_){}
    , decltype(_impl_.unknown_0_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_text().empty()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_line_box()) {
    _this->_impl_.line_box_ = new ::ocr_protobuf::OcrRespond_OcrBox(*from._impl_.line_box_);
  }
  if (from._internal_has_box10()) {
    _this->_impl_.box10_ = new ::ocr_protobuf::OcrRespond_OcrBox(*from._impl_.box10_);
  }
  ::memcpy(&_impl_.rate_, &from._impl_.rate_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.unknown_0_) -
    reinterpret_cast<char*>(&_impl_.rate_)) + sizeof(_impl_.unknown_0_));
  // @@protoc_insertion_point(copy_constructor:ocr_protobuf.OcrRespond.OCRResultLine)
}

inline void OcrRespond_OCRResultLine::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.blocks_){arena}
    , decltype(_impl_.text_){}
    , decltype(_impl_.line_box_){nullptr}
    , decltype(_impl_.box10_){nullptr}
    , decltype(_impl_.rate_){0}
    , decltype(_impl_.left_){0}
    , decltype(_impl_.top_){0}
    , decltype(_impl_.right_){0}
    , decltype(_impl_.bottom_){0}
    , decltype(_impl_.unknown_0_){false}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OcrRespond_OCRResultLine::~OcrRespond_OCRResultLine() {
  // @@protoc_insertion_point(destructor:ocr_protobuf.OcrRespond.OCRResultLine)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OcrRespond_OCRResultLine::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.blocks_.~RepeatedPtrField();
  _impl_.text_.Destroy();
  if (this != internal_default_instance()) delete _impl_.line_box_;
  if (this != internal_default_instance()) delete _impl_.box10_;
}

void OcrRespond_OCRResultLine::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OcrRespond_OCRResultLine::Clear() {
// @@protoc_insertion_point(message_clear_start:ocr_protobuf.OcrRespond.OCRResultLine)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.blocks_.Clear();
  _impl_.text_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.line_box_ != nullptr) {
    delete _impl_.line_box_;
  }
  _impl_.line_box_ = nullptr;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.box10_ != nullptr);
    _impl_.box10_->Clear();
  }
  ::memset(&_impl_.rate_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.bottom_) -
      reinterpret_cast<char*>(&_impl_.rate_)) + sizeof(_impl_.bottom_));
  _impl_.unknown_0_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OcrRespond_OCRResultLine::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .ocr_protobuf.OcrRespond.OcrBox line_box = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_line_box(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // float rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .ocr_protobuf.OcrRespond.OCRResultChar blocks = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_blocks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // float left = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.left_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float top = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.top_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float right = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.right_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float bottom = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.bottom_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool unknown_0 = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_unknown_0(&has_bits);
          _impl_.unknown_0_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ocr_protobuf.OcrRespond.OcrBox box10 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_box10(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OcrRespond_OCRResultLine::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ocr_protobuf.OcrRespond.OCRResultLine)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .ocr_protobuf.OcrRespond.OcrBox line_box = 1;
  if (this->_internal_has_line_box()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::line_box(this),
        _Internal::line_box(this).GetCachedSize(), target, stream);
  }

  // string text = 2;
  if (!this->_internal_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ocr_protobuf.OcrRespond.OCRResultLine.text");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_text(), target);
  }

  // float rate = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rate = this->_internal_rate();
  uint32_t raw_rate;
  memcpy(&raw_rate, &tmp_rate, sizeof(tmp_rate));
  if (raw_rate != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_rate(), target);
  }

  // repeated .ocr_protobuf.OcrRespond.OCRResultChar blocks = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_blocks_size()); i < n; i++) {
    const auto& repfield = this->_internal_blocks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // float left = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_left = this->_internal_left();
  uint32_t raw_left;
  memcpy(&raw_left, &tmp_left, sizeof(tmp_left));
  if (raw_left != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_left(), target);
  }

  // float top = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_top = this->_internal_top();
  uint32_t raw_top;
  memcpy(&raw_top, &tmp_top, sizeof(tmp_top));
  if (raw_top != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_top(), target);
  }

  // float right = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_right = this->_internal_right();
  uint32_t raw_right;
  memcpy(&raw_right, &tmp_right, sizeof(tmp_right));
  if (raw_right != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_right(), target);
  }

  // float bottom = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bottom = this->_internal_bottom();
  uint32_t raw_bottom;
  memcpy(&raw_bottom, &tmp_bottom, sizeof(tmp_bottom));
  if (raw_bottom != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_bottom(), target);
  }

  // optional bool unknown_0 = 9;
  if (_internal_has_unknown_0()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_unknown_0(), target);
  }

  // optional .ocr_protobuf.OcrRespond.OcrBox box10 = 10;
  if (_internal_has_box10()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::box10(this),
        _Internal::box10(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ocr_protobuf.OcrRespond.OCRResultLine)
  return target;
}

size_t OcrRespond_OCRResultLine::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ocr_protobuf.OcrRespond.OCRResultLine)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ocr_protobuf.OcrRespond.OCRResultChar blocks = 4;
  total_size += 1UL * this->_internal_blocks_size();
  for (const auto& msg : this->_impl_.blocks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string text = 2;
  if (!this->_internal_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  // .ocr_protobuf.OcrRespond.OcrBox line_box = 1;
  if (this->_internal_has_line_box()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.line_box_);
  }

  // optional .ocr_protobuf.OcrRespond.OcrBox box10 = 10;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.box10_);
  }

  // float rate = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rate = this->_internal_rate();
  uint32_t raw_rate;
  memcpy(&raw_rate, &tmp_rate, sizeof(tmp_rate));
  if (raw_rate != 0) {
    total_size += 1 + 4;
  }

  // float left = 5;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_left = this->_internal_left();
  uint32_t raw_left;
  memcpy(&raw_left, &tmp_left, sizeof(tmp_left));
  if (raw_left != 0) {
    total_size += 1 + 4;
  }

  // float top = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_top = this->_internal_top();
  uint32_t raw_top;
  memcpy(&raw_top, &tmp_top, sizeof(tmp_top));
  if (raw_top != 0) {
    total_size += 1 + 4;
  }

  // float right = 7;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_right = this->_internal_right();
  uint32_t raw_right;
  memcpy(&raw_right, &tmp_right, sizeof(tmp_right));
  if (raw_right != 0) {
    total_size += 1 + 4;
  }

  // float bottom = 8;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bottom = this->_internal_bottom();
  uint32_t raw_bottom;
  memcpy(&raw_bottom, &tmp_bottom, sizeof(tmp_bottom));
  if (raw_bottom != 0) {
    total_size += 1 + 4;
  }

  // optional bool unknown_0 = 9;
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OcrRespond_OCRResultLine::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OcrRespond_OCRResultLine*>(
      &from));
}

void OcrRespond_OCRResultLine::MergeFrom(const OcrRespond_OCRResultLine& from) {
  OcrRespond_OCRResultLine* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:ocr_protobuf.OcrRespond.OCRResultLine)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.blocks_.MergeFrom(from._impl_.blocks_);
  if (!from._internal_text().empty()) {
    _this->_internal_set_text(from._internal_text());
  }
  if (from._internal_has_line_box()) {
    _this->_internal_mutable_line_box()->::ocr_protobuf::OcrRespond_OcrBox::MergeFrom(
        from._internal_line_box());
  }
  if (from._internal_has_box10()) {
    _this->_internal_mutable_box10()->::ocr_protobuf::OcrRespond_OcrBox::MergeFrom(
        from._internal_box10());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rate = from._internal_rate();
  uint32_t raw_rate;
  memcpy(&raw_rate, &tmp_rate, sizeof(tmp_rate));
  if (raw_rate != 0) {
    _this->_internal_set_rate(from._internal_rate());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_left = from._internal_left();
  uint32_t raw_left;
  memcpy(&raw_left, &tmp_left, sizeof(tmp_left));
  if (raw_left != 0) {
    _this->_internal_set_left(from._internal_left());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_top = from._internal_top();
  uint32_t raw_top;
  memcpy(&raw_top, &tmp_top, sizeof(tmp_top));
  if (raw_top != 0) {
    _this->_internal_set_top(from._internal_top());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_right = from._internal_right();
  uint32_t raw_right;
  memcpy(&raw_right, &tmp_right, sizeof(tmp_right));
  if (raw_right != 0) {
    _this->_internal_set_right(from._internal_right());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bottom = from._internal_bottom();
  uint32_t raw_bottom;
  memcpy(&raw_bottom, &tmp_bottom, sizeof(tmp_bottom));
  if (raw_bottom != 0) {
    _this->_internal_set_bottom(from._internal_bottom());
  }
  if (from._internal_has_unknown_0()) {
    _this->_internal_set_unknown_0(from._internal_unknown_0());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OcrRespond_OCRResultLine::CopyFrom(const OcrRespond_OCRResultLine& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ocr_protobuf.OcrRespond.OCRResultLine)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OcrRespond_OCRResultLine::IsInitialized() const {
  return true;
}

void OcrRespond_OCRResultLine::InternalSwap(OcrRespond_OCRResultLine* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.blocks_.InternalSwap(&other->_impl_.blocks_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OcrRespond_OCRResultLine, _impl_.unknown_0_)
      + sizeof(OcrRespond_OCRResultLine::_impl_.unknown_0_)
      - PROTOBUF_FIELD_OFFSET(OcrRespond_OCRResultLine, _impl_.line_box_)>(
          reinterpret_cast<char*>(&_impl_.line_box_),
          reinterpret_cast<char*>(&other->_impl_.line_box_));
}

std::string OcrRespond_OCRResultLine::GetTypeName() const {
  return "ocr_protobuf.OcrRespond.OCRResultLine";
}


// ===================================================================

class OcrRespond_OcrOutputBuffer::_Internal {
 public:
  using HasBits = decltype(std::declval<OcrRespond_OcrOutputBuffer>()._impl_._has_bits_);
  static void set_has_img_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_img_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_unk4(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

OcrRespond_OcrOutputBuffer::OcrRespond_OcrOutputBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ocr_protobuf.OcrRespond.OcrOutputBuffer)
}
OcrRespond_OcrOutputBuffer::OcrRespond_OcrOutputBuffer(const OcrRespond_OcrOutputBuffer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OcrRespond_OcrOutputBuffer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lines_){from._impl_.lines_}
    , decltype(_impl_.unk4_){}
    , decltype(_impl_.img_width_){}
    , decltype(_impl_.img_height_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.unk4_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unk4_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_unk4()) {
    _this->_impl_.unk4_.Set(from._internal_unk4(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.img_width_, &from._impl_.img_width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.img_height_) -
    reinterpret_cast<char*>(&_impl_.img_width_)) + sizeof(_impl_.img_height_));
  // @@protoc_insertion_point(copy_constructor:ocr_protobuf.OcrRespond.OcrOutputBuffer)
}

inline void OcrRespond_OcrOutputBuffer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.lines_){arena}
    , decltype(_impl_.unk4_){}
    , decltype(_impl_.img_width_){0u}
    , decltype(_impl_.img_height_){0u}
  };
  _impl_.unk4_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.unk4_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OcrRespond_OcrOutputBuffer::~OcrRespond_OcrOutputBuffer() {
  // @@protoc_insertion_point(destructor:ocr_protobuf.OcrRespond.OcrOutputBuffer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OcrRespond_OcrOutputBuffer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.lines_.~RepeatedPtrField();
  _impl_.unk4_.Destroy();
}

void OcrRespond_OcrOutputBuffer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OcrRespond_OcrOutputBuffer::Clear() {
// @@protoc_insertion_point(message_clear_start:ocr_protobuf.OcrRespond.OcrOutputBuffer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.lines_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.unk4_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.img_width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.img_height_) -
        reinterpret_cast<char*>(&_impl_.img_width_)) + sizeof(_impl_.img_height_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OcrRespond_OcrOutputBuffer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ocr_protobuf.OcrRespond.OCRResultLine lines = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_lines(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 img_width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_img_width(&has_bits);
          _impl_.img_width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 img_height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_img_height(&has_bits);
          _impl_.img_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string unk4 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_unk4();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OcrRespond_OcrOutputBuffer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ocr_protobuf.OcrRespond.OcrOutputBuffer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ocr_protobuf.OcrRespond.OCRResultLine lines = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_lines_size()); i < n; i++) {
    const auto& repfield = this->_internal_lines(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 img_width = 2;
  if (_internal_has_img_width()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_img_width(), target);
  }

  // optional uint32 img_height = 3;
  if (_internal_has_img_height()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_img_height(), target);
  }

  // optional string unk4 = 4;
  if (_internal_has_unk4()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_unk4().data(), static_cast<int>(this->_internal_unk4().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ocr_protobuf.OcrRespond.OcrOutputBuffer.unk4");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_unk4(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ocr_protobuf.OcrRespond.OcrOutputBuffer)
  return target;
}

size_t OcrRespond_OcrOutputBuffer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ocr_protobuf.OcrRespond.OcrOutputBuffer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ocr_protobuf.OcrRespond.OCRResultLine lines = 1;
  total_size += 1UL * this->_internal_lines_size();
  for (const auto& msg : this->_impl_.lines_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string unk4 = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_unk4());
    }

    // optional uint32 img_width = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_img_width());
    }

    // optional uint32 img_height = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_img_height());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OcrRespond_OcrOutputBuffer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OcrRespond_OcrOutputBuffer*>(
      &from));
}

void OcrRespond_OcrOutputBuffer::MergeFrom(const OcrRespond_OcrOutputBuffer& from) {
  OcrRespond_OcrOutputBuffer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:ocr_protobuf.OcrRespond.OcrOutputBuffer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.lines_.MergeFrom(from._impl_.lines_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_unk4(from._internal_unk4());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.img_width_ = from._impl_.img_width_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.img_height_ = from._impl_.img_height_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OcrRespond_OcrOutputBuffer::CopyFrom(const OcrRespond_OcrOutputBuffer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ocr_protobuf.OcrRespond.OcrOutputBuffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OcrRespond_OcrOutputBuffer::IsInitialized() const {
  return true;
}

void OcrRespond_OcrOutputBuffer::InternalSwap(OcrRespond_OcrOutputBuffer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.lines_.InternalSwap(&other->_impl_.lines_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.unk4_, lhs_arena,
      &other->_impl_.unk4_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OcrRespond_OcrOutputBuffer, _impl_.img_height_)
      + sizeof(OcrRespond_OcrOutputBuffer::_impl_.img_height_)
      - PROTOBUF_FIELD_OFFSET(OcrRespond_OcrOutputBuffer, _impl_.img_width_)>(
          reinterpret_cast<char*>(&_impl_.img_width_),
          reinterpret_cast<char*>(&other->_impl_.img_width_));
}

std::string OcrRespond_OcrOutputBuffer::GetTypeName() const {
  return "ocr_protobuf.OcrRespond.OcrOutputBuffer";
}


// ===================================================================

class OcrRespond::_Internal {
 public:
  using HasBits = decltype(std::declval<OcrRespond>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_task_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_err_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::ocr_protobuf::OcrRespond_OcrOutputBuffer& ocr_result(const OcrRespond* msg);
  static void set_has_ocr_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::ocr_protobuf::OcrRespond_OcrOutputBuffer&
OcrRespond::_Internal::ocr_result(const OcrRespond* msg) {
  return *msg->_impl_.ocr_result_;
}
OcrRespond::OcrRespond(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ocr_protobuf.OcrRespond)
}
OcrRespond::OcrRespond(const OcrRespond& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OcrRespond* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ocr_result_){nullptr}
    , decltype(_impl_.task_id_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.err_code_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_ocr_result()) {
    _this->_impl_.ocr_result_ = new ::ocr_protobuf::OcrRespond_OcrOutputBuffer(*from._impl_.ocr_result_);
  }
  ::memcpy(&_impl_.task_id_, &from._impl_.task_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.err_code_) -
    reinterpret_cast<char*>(&_impl_.task_id_)) + sizeof(_impl_.err_code_));
  // @@protoc_insertion_point(copy_constructor:ocr_protobuf.OcrRespond)
}

inline void OcrRespond::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ocr_result_){nullptr}
    , decltype(_impl_.task_id_){uint64_t{0u}}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.err_code_){0}
  };
}

OcrRespond::~OcrRespond() {
  // @@protoc_insertion_point(destructor:ocr_protobuf.OcrRespond)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OcrRespond::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.ocr_result_;
}

void OcrRespond::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OcrRespond::Clear() {
// @@protoc_insertion_point(message_clear_start:ocr_protobuf.OcrRespond)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.ocr_result_ != nullptr);
    _impl_.ocr_result_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.task_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.err_code_) -
        reinterpret_cast<char*>(&_impl_.task_id_)) + sizeof(_impl_.err_code_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OcrRespond::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 task_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_task_id(&has_bits);
          _impl_.task_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 err_code = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_err_code(&has_bits);
          _impl_.err_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ocr_protobuf.OcrRespond.OcrOutputBuffer ocr_result = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_ocr_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OcrRespond::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ocr_protobuf.OcrRespond)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 type = 1;
  if (_internal_has_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_type(), target);
  }

  // optional uint64 task_id = 2;
  if (_internal_has_task_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_task_id(), target);
  }

  // optional int32 err_code = 3;
  if (_internal_has_err_code()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_err_code(), target);
  }

  // optional .ocr_protobuf.OcrRespond.OcrOutputBuffer ocr_result = 4;
  if (_internal_has_ocr_result()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::ocr_result(this),
        _Internal::ocr_result(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ocr_protobuf.OcrRespond)
  return target;
}

size_t OcrRespond::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ocr_protobuf.OcrRespond)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .ocr_protobuf.OcrRespond.OcrOutputBuffer ocr_result = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ocr_result_);
    }

    // optional uint64 task_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_task_id());
    }

    // optional int32 type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 err_code = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_err_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OcrRespond::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OcrRespond*>(
      &from));
}

void OcrRespond::MergeFrom(const OcrRespond& from) {
  OcrRespond* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:ocr_protobuf.OcrRespond)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_ocr_result()->::ocr_protobuf::OcrRespond_OcrOutputBuffer::MergeFrom(
          from._internal_ocr_result());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.task_id_ = from._impl_.task_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.err_code_ = from._impl_.err_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OcrRespond::CopyFrom(const OcrRespond& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ocr_protobuf.OcrRespond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OcrRespond::IsInitialized() const {
  return true;
}

void OcrRespond::InternalSwap(OcrRespond* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OcrRespond, _impl_.err_code_)
      + sizeof(OcrRespond::_impl_.err_code_)
      - PROTOBUF_FIELD_OFFSET(OcrRespond, _impl_.ocr_result_)>(
          reinterpret_cast<char*>(&_impl_.ocr_result_),
          reinterpret_cast<char*>(&other->_impl_.ocr_result_));
}

std::string OcrRespond::GetTypeName() const {
  return "ocr_protobuf.OcrRespond";
}


// ===================================================================

class OcrRequest_OcrInputBuffer::_Internal {
 public:
  using HasBits = decltype(std::declval<OcrRequest_OcrInputBuffer>()._impl_._has_bits_);
  static void set_has_pic_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_u2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_u3(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_pic_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

OcrRequest_OcrInputBuffer::OcrRequest_OcrInputBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ocr_protobuf.OcrRequest.OcrInputBuffer)
}
OcrRequest_OcrInputBuffer::OcrRequest_OcrInputBuffer(const OcrRequest_OcrInputBuffer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OcrRequest_OcrInputBuffer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pic_path_){}
    , decltype(_impl_.pic_data_){}
    , decltype(_impl_.u2_){}
    , decltype(_impl_.u3_){}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  _impl_.pic_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pic_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pic_path()) {
    _this->_impl_.pic_path_.Set(from._internal_pic_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pic_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pic_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pic_data()) {
    _this->_impl_.pic_data_.Set(from._internal_pic_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.u2_, &from._impl_.u2_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.u3_) -
    reinterpret_cast<char*>(&_impl_.u2_)) + sizeof(_impl_.u3_));
  // @@protoc_insertion_point(copy_constructor:ocr_protobuf.OcrRequest.OcrInputBuffer)
}

inline void OcrRequest_OcrInputBuffer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pic_path_){}
    , decltype(_impl_.pic_data_){}
    , decltype(_impl_.u2_){0u}
    , decltype(_impl_.u3_){0u}
  };
  _impl_.pic_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pic_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pic_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pic_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

OcrRequest_OcrInputBuffer::~OcrRequest_OcrInputBuffer() {
  // @@protoc_insertion_point(destructor:ocr_protobuf.OcrRequest.OcrInputBuffer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OcrRequest_OcrInputBuffer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.pic_path_.Destroy();
  _impl_.pic_data_.Destroy();
}

void OcrRequest_OcrInputBuffer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OcrRequest_OcrInputBuffer::Clear() {
// @@protoc_insertion_point(message_clear_start:ocr_protobuf.OcrRequest.OcrInputBuffer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.pic_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.pic_data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.u2_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.u3_) -
        reinterpret_cast<char*>(&_impl_.u2_)) + sizeof(_impl_.u3_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* OcrRequest_OcrInputBuffer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string pic_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_pic_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 u2 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_u2(&has_bits);
          _impl_.u2_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 u3 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_u3(&has_bits);
          _impl_.u3_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pic_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_pic_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OcrRequest_OcrInputBuffer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ocr_protobuf.OcrRequest.OcrInputBuffer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional string pic_path = 1;
  if (_internal_has_pic_path()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_pic_path().data(), static_cast<int>(this->_internal_pic_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ocr_protobuf.OcrRequest.OcrInputBuffer.pic_path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_pic_path(), target);
  }

  // optional uint32 u2 = 2;
  if (_internal_has_u2()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_u2(), target);
  }

  // optional uint32 u3 = 3;
  if (_internal_has_u3()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_u3(), target);
  }

  // optional bytes pic_data = 4;
  if (_internal_has_pic_data()) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_pic_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ocr_protobuf.OcrRequest.OcrInputBuffer)
  return target;
}

size_t OcrRequest_OcrInputBuffer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ocr_protobuf.OcrRequest.OcrInputBuffer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string pic_path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_pic_path());
    }

    // optional bytes pic_data = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pic_data());
    }

    // optional uint32 u2 = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u2());
    }

    // optional uint32 u3 = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_u3());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OcrRequest_OcrInputBuffer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OcrRequest_OcrInputBuffer*>(
      &from));
}

void OcrRequest_OcrInputBuffer::MergeFrom(const OcrRequest_OcrInputBuffer& from) {
  OcrRequest_OcrInputBuffer* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:ocr_protobuf.OcrRequest.OcrInputBuffer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_pic_path(from._internal_pic_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_pic_data(from._internal_pic_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.u2_ = from._impl_.u2_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.u3_ = from._impl_.u3_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OcrRequest_OcrInputBuffer::CopyFrom(const OcrRequest_OcrInputBuffer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ocr_protobuf.OcrRequest.OcrInputBuffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OcrRequest_OcrInputBuffer::IsInitialized() const {
  return true;
}

void OcrRequest_OcrInputBuffer::InternalSwap(OcrRequest_OcrInputBuffer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pic_path_, lhs_arena,
      &other->_impl_.pic_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pic_data_, lhs_arena,
      &other->_impl_.pic_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OcrRequest_OcrInputBuffer, _impl_.u3_)
      + sizeof(OcrRequest_OcrInputBuffer::_impl_.u3_)
      - PROTOBUF_FIELD_OFFSET(OcrRequest_OcrInputBuffer, _impl_.u2_)>(
          reinterpret_cast<char*>(&_impl_.u2_),
          reinterpret_cast<char*>(&other->_impl_.u2_));
}

std::string OcrRequest_OcrInputBuffer::GetTypeName() const {
  return "ocr_protobuf.OcrRequest.OcrInputBuffer";
}


// ===================================================================

class OcrRequest::_Internal {
 public:
  static const ::ocr_protobuf::OcrRequest_OcrInputBuffer& input(const OcrRequest* msg);
};

const ::ocr_protobuf::OcrRequest_OcrInputBuffer&
OcrRequest::_Internal::input(const OcrRequest* msg) {
  return *msg->_impl_.input_;
}
OcrRequest::OcrRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ocr_protobuf.OcrRequest)
}
OcrRequest::OcrRequest(const OcrRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  OcrRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.input_){nullptr}
    , decltype(_impl_.task_id_){}
    , decltype(_impl_.unknow_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_input()) {
    _this->_impl_.input_ = new ::ocr_protobuf::OcrRequest_OcrInputBuffer(*from._impl_.input_);
  }
  ::memcpy(&_impl_.task_id_, &from._impl_.task_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.unknow_) -
    reinterpret_cast<char*>(&_impl_.task_id_)) + sizeof(_impl_.unknow_));
  // @@protoc_insertion_point(copy_constructor:ocr_protobuf.OcrRequest)
}

inline void OcrRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.input_){nullptr}
    , decltype(_impl_.task_id_){uint64_t{0u}}
    , decltype(_impl_.unknow_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

OcrRequest::~OcrRequest() {
  // @@protoc_insertion_point(destructor:ocr_protobuf.OcrRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void OcrRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.input_;
}

void OcrRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void OcrRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:ocr_protobuf.OcrRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.input_ != nullptr) {
    delete _impl_.input_;
  }
  _impl_.input_ = nullptr;
  ::memset(&_impl_.task_id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.unknow_) -
      reinterpret_cast<char*>(&_impl_.task_id_)) + sizeof(_impl_.unknow_));
  _internal_metadata_.Clear<std::string>();
}

const char* OcrRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 unknow = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.unknow_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 task_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.task_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ocr_protobuf.OcrRequest.OcrInputBuffer input = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_input(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* OcrRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ocr_protobuf.OcrRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 unknow = 1;
  if (this->_internal_unknow() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_unknow(), target);
  }

  // uint64 task_id = 2;
  if (this->_internal_task_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_task_id(), target);
  }

  // .ocr_protobuf.OcrRequest.OcrInputBuffer input = 3;
  if (this->_internal_has_input()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::input(this),
        _Internal::input(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ocr_protobuf.OcrRequest)
  return target;
}

size_t OcrRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ocr_protobuf.OcrRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .ocr_protobuf.OcrRequest.OcrInputBuffer input = 3;
  if (this->_internal_has_input()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.input_);
  }

  // uint64 task_id = 2;
  if (this->_internal_task_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_task_id());
  }

  // int32 unknow = 1;
  if (this->_internal_unknow() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_unknow());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void OcrRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const OcrRequest*>(
      &from));
}

void OcrRequest::MergeFrom(const OcrRequest& from) {
  OcrRequest* const _this = this;
  // @@protoc_insertion_point(class_specific_merge_from_start:ocr_protobuf.OcrRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_input()) {
    _this->_internal_mutable_input()->::ocr_protobuf::OcrRequest_OcrInputBuffer::MergeFrom(
        from._internal_input());
  }
  if (from._internal_task_id() != 0) {
    _this->_internal_set_task_id(from._internal_task_id());
  }
  if (from._internal_unknow() != 0) {
    _this->_internal_set_unknow(from._internal_unknow());
  }
  _this->_internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void OcrRequest::CopyFrom(const OcrRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ocr_protobuf.OcrRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OcrRequest::IsInitialized() const {
  return true;
}

void OcrRequest::InternalSwap(OcrRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(OcrRequest, _impl_.unknow_)
      + sizeof(OcrRequest::_impl_.unknow_)
      - PROTOBUF_FIELD_OFFSET(OcrRequest, _impl_.input_)>(
          reinterpret_cast<char*>(&_impl_.input_),
          reinterpret_cast<char*>(&other->_impl_.input_));
}

std::string OcrRequest::GetTypeName() const {
  return "ocr_protobuf.OcrRequest";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace ocr_protobuf
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::ocr_protobuf::OcrRespond_OcrBoxPoint*
Arena::CreateMaybeMessage< ::ocr_protobuf::OcrRespond_OcrBoxPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ocr_protobuf::OcrRespond_OcrBoxPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::ocr_protobuf::OcrRespond_OcrBox*
Arena::CreateMaybeMessage< ::ocr_protobuf::OcrRespond_OcrBox >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ocr_protobuf::OcrRespond_OcrBox >(arena);
}
template<> PROTOBUF_NOINLINE ::ocr_protobuf::OcrRespond_OCRResultChar*
Arena::CreateMaybeMessage< ::ocr_protobuf::OcrRespond_OCRResultChar >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ocr_protobuf::OcrRespond_OCRResultChar >(arena);
}
template<> PROTOBUF_NOINLINE ::ocr_protobuf::OcrRespond_OCRResultLine*
Arena::CreateMaybeMessage< ::ocr_protobuf::OcrRespond_OCRResultLine >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ocr_protobuf::OcrRespond_OCRResultLine >(arena);
}
template<> PROTOBUF_NOINLINE ::ocr_protobuf::OcrRespond_OcrOutputBuffer*
Arena::CreateMaybeMessage< ::ocr_protobuf::OcrRespond_OcrOutputBuffer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ocr_protobuf::OcrRespond_OcrOutputBuffer >(arena);
}
template<> PROTOBUF_NOINLINE ::ocr_protobuf::OcrRespond*
Arena::CreateMaybeMessage< ::ocr_protobuf::OcrRespond >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ocr_protobuf::OcrRespond >(arena);
}
template<> PROTOBUF_NOINLINE ::ocr_protobuf::OcrRequest_OcrInputBuffer*
Arena::CreateMaybeMessage< ::ocr_protobuf::OcrRequest_OcrInputBuffer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ocr_protobuf::OcrRequest_OcrInputBuffer >(arena);
}
template<> PROTOBUF_NOINLINE ::ocr_protobuf::OcrRequest*
Arena::CreateMaybeMessage< ::ocr_protobuf::OcrRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ocr_protobuf::OcrRequest >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
